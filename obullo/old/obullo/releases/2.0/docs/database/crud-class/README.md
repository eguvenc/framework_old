### CRUD Class <a name="crud-class"></a>

------

This class allows information to be retrieved, inserted, and updated in your database with minimal scripting. In some cases only one or two lines of code are necessary to perform a database action.

Beyond simplicity, a major benefit of using the Active Record features is that it allows you to create database independent applications, since the query syntax is generated by each database adapter. It also allows for safer queries, since the values are escaped automatically by the system.

**Note:** If you intend to write your own queries you can disable this class in your <b>database config</b> file, allowing the core database library and adapter to utilize fewer resources.

**Tip**: You can also use <b>PDO query bind</b> functionality with CRUD Class.

[Selecting Data](#selecting-data)
[Inserting Data](#inserting-data)
[Updating Data](#updating-data)
[Deleting Data](#deleting-data)
[Method Chaining](#method-chaining)
[Active Record Caching](#active-record-chaining)

### Selecting Data<a name="#selecting-data"></a>

------

The following functions allow you to build SQL <b>SELECT</b> statements.

<b>Note: You can use method chaining for more compact syntax. This is described at the end of the page.</b>

#### $this->db->get();

Runs the selection query and returns the result. Can be used by itself to retrieve all records from a table:

```php
$query = $this->db->get('mytable');

// Produces: SELECT * FROM mytable
```

The second and third parameters enable you to set a limit and offset clause:

```php
$query = $this->db->get('mytable', 10, 20);

// Produces: SELECT * FROM mytable LIMIT 20, 10 (in MySQL. Other databases have slightly different syntax)
```
You will notice that the above function is assigned to a variable named <kbd>$query</kbd>, which can be used to show the results:

```php
$query = $this->db->get('mytable');

foreach($query->fetchAll() as $row)
{
    echo $row->title;
}
```

Please visit the result functions page for a full discussion regarding result generation.


#### $this->db->select();

Permits you to write the SELECT portion of your query:

```php
$this->db->select('title, content, date');

$query = $this->db->get('mytable');

// Produces: SELECT title, content, date FROM mytab
```

**Note:** If you are selecting all (*) from a table you do not need to use this function. When omitted, Obullo assumes you wish to SELECT *

$this->db->select() accepts an optional second parameter. If you set it to false, Obullo will not try to protect your field or table names with backticks. This is useful if you need a compound select statement.

```php
$this->db->select("SELECT SUM(payments.amount), 
                   FROM_UNIXTIME( `field_date` , '%d.%m.%Y %H:%i' ) as date", false);
                   
$query = $this->db->get('mytable');

// Produces:
SELECT SUM(payments.amount), 
FROM_UNIXTIME( `field_date` , '%d.%m.%Y %H:%i' ) as date
FROM mytable;
```

You can put " select commands " into $this->db->select() function like this ..

```php
$this->db->select("SELECT MAX(age) as max_age, active,
                   AVG(age) as avg_age,
                   DATE_FORMAT(field, '%d-%m-%Y') as date", false);
                   
$this->db->where('active', 1);
$this->db->get('mytable');

// Produces:
SELECT MAX(age) as max_age, active,
AVG(age) as avg_age,
DATE_FORMAT(field, '%d-%m-%Y') as date
FROM mytable
WHERE active = '1'
```

#### $this->db->from();

Permits you to write the FROM portion of your query:

```php
$this->db->select('title, content, date');
$this->db->from('mytable');

$query = $this->db->get();

// Produces: SELECT title, content, date FROM mytable
```

**Note:** As shown earlier, the FROM portion of your query can be specified in the <dfn>$this->db->get()</dfn> function, so use whichever method you prefer.

#### $this->db->join();

Permits you to write the JOIN portion of your query:

```php
$this->db->select('*');
$this->db->from('blogs');
$this->db->join('comments', 'comments.id = blogs.id');

$query = $this->db->get();

// Produces:
```
Multiple function calls can be made if you need several joins in one query.

If you need something other than a natural JOIN you can specify it via the third parameter of the function. Options are: left, right, outer, inner, left outer, and right outer.

```php
$this->db->join('comments', 'comments.id = blogs.id', 'left');

// Produces: LEFT JOIN comments ON comments.id = blogs.id
```

#### $this->db->where();

This function enables you to set <b>WHERE</b> clauses using one of four methods:

**Note:** All values passed to this function are escaped automatically, producing safer queries except the LIKE statement, for like statements you should use $this->escapeLike() function for more details look at this page running and escaping queries.

    <h4>Simple key/value method:</h4>

```php
$this->db->where('name', $name);

// Produces: WHERE name = 'Joe'
```

Notice that the equal sign is added for you.

If you use multiple function calls they will be chained together with <var>AND</var> between them:

```php
    $this->db->where('name', $name);
    $this->db->where('title', $title);
    $this->db->where('status', $status);

    // WHERE name 'Joe' AND title = 'boss' AND status = 'active'
```
    
<h4>Custom key/value method:</h4>

    You can include an operator in the first parameter in order to control the comparison:

```php
    $this->db->where('name !=', $name);
    $this->db->where('id <', $id);

    // Produces: WHERE name != 'Joe' AND id < 45 
```    

<h4>Associative array method:</h4> 
    
```php    
$array = array('name' => $name, 'title' => $title, 'status' => $status);

$this->db->where($array);

// Produces: WHERE name = 'Joe' AND title = 'boss' AND status = 'active'
```

You can include your own operators using this method as well:

```php
$array = array('name !=' => $name, 'id <' => $id, 'date >' => $date);

$this->db->where($array);
```

<h4>Custom string:</h4>

You can write your own clauses manually:

```php
$where = "name='Joe' AND status='boss' OR status='active'";

$this->db->where($where);
```

$this->db->where() accepts an optional third parameter. If you set it to false, Obullo will not try to protect your field or table names with backticks.

```php
$this->db->where('MATCH (field) AGAINST ("value")', NULL, false);

```

#### $this->db->orWhere();

This function is identical to the one above, except that multiple instances are joined by OR:

```php
$this->db->where('name !=', $name);
$this->db->orWhere('id >', $id);

// Produces: WHERE name != 'Joe' OR id > 50
```

**Note:** orWhere() was formerly known as orwhere(), which has been deprecated.


#### $this->db->whereIn();

Generates a WHERE field IN ('item', 'item') SQL query joined with AND if appropriate

```php
$names = array('Hassan', 'Bob', 'Yokamoto');
$this->db->whereIn('username', $names);

// Produces: WHERE username IN ('Hassan', 'Bob', 'Yokamoto')
```

#### $this->db->orWhereIn();

Generates a WHERE field IN ('item', 'item') SQL query joined with OR if appropriate

```php
$names = array('Frank', 'Todd', 'James');
$this->db->whereIn('username', $names);

// Produces: WHERE username IN ('Frank', 'Todd', 'James')
```

#### $this->db->whereNotIn();

Generates a WHERE field NOT IN ('item', 'item') SQL query joined with AND if appropriate

```php
$names = array('Frank', 'Todd', 'James');
$this->db->whereNotIn('username', $names);

// Produces: WHERE username NOT IN ('Frank', 'Todd', 'James')

```

#### $this->db->orWhereNotIn();

Generates a WHERE field NOT IN ('item', 'item') SQL query joined with OR if appropriate

```php
$names = array('Frank', 'Todd', 'James');
$this->db->orWhereNotIn('username', $names);

// Produces: OR username NOT IN ('Frank', 'Todd', 'James')
```

#### $this->db->like();

This function enables you to generate <b>LIKE</b> clauses, useful for doing searches.


**Note:** All values passed to this function are escaped automatically but if you use query bind functionality you must be use *$this->db->escape_like()* function manually, look at next page.

  
<h4>Simple key/value method:</h4>

```php
 $this->db->like('title', 'match');

// Produces: WHERE title LIKE '%match%' 
```

If you use multiple function calls they will be chained together with <var>AND</var> between them:
    
```php
$this->db->like('title', 'match');
$this->db->like('body', 'match');

// WHERE title LIKE '%match%' AND body LIKE '%match% 
```

If you want to control where the wildcard (%) is placed, you can use an optional third argument. Your options are 'before', 'after' and 'both' (which is the default). 

```php
$this->db->like('title', 'match', 'before');
// Produces: WHERE title LIKE '%match'

$this->db->like('title', 'match', 'after');
// Produces: WHERE title LIKE 'match%'

$this->db->like('title', 'match', 'both');
// Produces: WHERE title LIKE '%match%'
```   
 
<h4>Associative array method:</h4>

```php
$array = array('title' => $match, 'page1' => $match, 'page2' => $match);

$this->db->like($array);

// WHERE title LIKE '%match%' AND page1 LIKE '%match%' AND page2 LIKE '%match%'
```


#### $this->db->orLike();

This function is identical to the one above, except that multiple instances are joined by OR:

```php
$this->db->like('title', 'match');
$this->db->orLike('body', $match);

// WHERE title LIKE '%match%' OR body LIKE '%match%'

```

#### $this->db->notLike();

This function is identical to <b>like()</b>, except that it generates NOT LIKE statements:

```php
$this->db->notLike('title', 'match');

// WHERE title NOT LIKE '%match%
```

#### $this->db->orNotLike();

This function is identical to <b>notLike()</b>, except that multiple instances are joined by OR:

```php
$this->db->notLike('title', 'match');
$this->db->orNotLike('body', 'match');

// WHERE title NOT LIKE '%match%
```

#### $this->db->groupBy();

Permits you to write the GROUP BY portion of your query:

```php
$this->db->groupBy("title");

// Produces: GROUP BY title
```

You can also pass an array of multiple values as well:


```php
$this->db->groupBy(array("title", "date"));

// Produces: GROUP BY title, date
```

#### $this->db->distinct();

Adds the <b>DISTINCT</b> keyword to a query

```php
$this->db->distinct();
$this->db->get('table');

// Produces: SELECT DISTINCT * FROM table
```

#### $this->db->having();

Permits you to write the HAVING portion of your query. There are 2 possible syntaxes, 1 argument or 2:

```php
$this->db->having('user_id = 45');
// Produces: HAVING user_id = 45

$this->db->having('user_id', 45);
// Produces: HAVING user_id = 45
```

You can also pass an array of multiple values as well:

```php
$this->db->having(array('title =' => 'My Title', 'id <' => $id));

// Produces: HAVING title = 'My Title', id < 45
```

If you are using a database that Obullo escapes queries for, you can prevent escaping content by passing an optional third argument, and setting it to false.

```php
$this->db->having('user_id', 45);
// Produces: HAVING `user_id` = 45 in some databases such as MySQL

$this->db->having('user_id', 45, false);
// Produces: HAVING user_id = 45

```

#### $this->db->orHaving();

Identical to having(), only separates multiple clauses with <b>OR</b>

#### $this->db->orderBy();

Lets you set an ORDER BY clause. The first parameter contains the name of the column you would like to order by. The second parameter lets you set the direction of the result. Options are <kbd>asc</kbd> or <kbd>desc</kbd>


```php
$this->db->orderBy("title", "desc");

// Produces: ORDER BY title DESC 
```

You can also pass your own string in the first parameter:


```php
$this->db->orderBy('title desc, name asc');

// Produces: ORDER BY title DESC, name ASC
```

Or multiple function calls can be made if you need multiple fields.

```php
$this->db->orderBy("title", "desc");
$this->db->orderBy("name", "asc");


// Produces: ORDER BY title DESC, name ASC
```

#### $this->db->limit();

Lets you limit the number of rows you would like returned by the query:

```php
$this->db->limit(10);

// Produces: LIMIT 10
```

The second parameter lets you set a result offset.

```php
$this->db->limit(10, 20);

// Produces: LIMIT 20, 10 // in MySQL. Other databases have slightly different syntax
```

### Inserting Data

------

#### $this->db->insert();

Generates an insert string based on the data you supply, and runs the query. You can either pass an <b>array</b> or an <b>object</b> to the function. Here is an example using an array:

```php
$data = array(
               'title' => 'My title' ,
               'name' => 'My Name' ,
               'date' => 'My date'
            );

$this->db->insert('mytable', $data);

// Produces: INSERT INTO mytable (title, name, date) VALUES ('My title', 'My name', 'My date')
```
The first parameter will contain the table name, the second is an associative array of values.

Here is an example using an object:

```php
/*
    class Myclass {
        public $title = 'My Title';
        public $content = 'My Content';
        public $date = 'My Date';
    }
*/

$object = new Myclass;

$this->db->insert('mytable', $object);

// Produces: INSERT INTO mytable (title, content, date) VALUES ('My Title', 'My Content', 'My Date')
```

The first parameter will contain the table name, the second is an associative array of values.

**Note:** All values are escaped automatically producing safer queries.

#### $this->db->set();

This function enables you to set values for <dfn>inserts</dfn> or <dfn>updates</dfn>.

<b>It can be used instead of passing a data array directly to the insert or update functions:</b>

```php
$this->db->set('name', $name);
$this->db->insert('mytable');

// Produces: INSERT INTO mytable (name) VALUES ('{$name}')
```

If you use multiple function called they will be assembled properly based on whether you are doing an insert or an update:

```php
$this->db->set('name', $name);
$this->db->set('title', $title);
$this->db->set('status', $status);
$this->db->insert('mytable');
```

<b>set()</b> will also accept an optional third parameter ($escape), that will prevent data from being escaped if set to false. To illustrate the difference, here is set() used both with and without the escape parameter.

```php
$this->db->set('field', 'field+1', false);
$this->db->insert('mytable');
// gives INSERT INTO mytable (field) VALUES (field+1)

$this->db->set('field', 'field+1');
$this->db->insert('mytable');
// gives INSERT INTO mytable (field) VALUES ('field+1')
```

You can also pass an associative array to this function:

```php
$array = array('name' => $name, 'title' => $title, 'status' => $status);

$this->db->set($array);
$this->db->insert('mytable'); 
```

Or an object:

```php
/*
    class Myclass {
        public $title = 'My Title';
        public $content = 'My Content';
        public $date = 'My Date';
    }
*/

$object = new Myclass;

$this->db->set($object);
$affected_rows = $this->db->insert('mytable'); 
echo $affected_rows;  // 1
```

**Note:** INSERT , UPDATE and DELETE operations returns to affected rows automatically. You don't need to *rowCount()* function for these methods.

### Updating Data <a name="updating-data"></a>

------

#### $this->db->update();

Generates an update string and runs the query based on the data you supply. You can pass an <b>array</b> or an <b>object</b> to the function. Here is an example using an array:

```php
$data = array(
               'title' => $title,
               'name' => $name,
               'date' => $date
            );

$this->db->where('id', $id);
$affected_rows = $this->db->update('mytable', $data);
echo $affected_rows;  // 1
```

Or you can supply an object:

```php
/*
    class Myclass {
        var $title = 'My Title';
        var $content = 'My Content';
        var $date = 'My Date';
    }
*/

$object = new Myclass;

$this->db->where('id', $id);
$this->db->update('mytable', $object);
```

**Note:** All values are escaped automatically producing safer queries.

You'll notice the use of the $this->db->where() function, enabling you to set the WHERE clause. You can optionally pass this information directly into the update function as a string:

```php
$this->db->update('mytable', $data, "id = 4");
```
Or as an array:

```php
$this->db->update('mytable', $data, array('id' => $id));
```

You may also use the <dfn>$this->db->set()</dfn> function described above when performing updates.

### Deleting Data <a name="deleting-data"></a>

------

#### $this->db->delete();

Generates a delete SQL string and runs the query.

```php
$this->db->delete('mytable', array('id' => $id));
```
The first parameter is the table name, the second is the where clause. You can also use the <dfn>where()</dfn> or <dfn>orWhere()</dfn> functions instead of passing the data to the second parameter of the function:

```php
$this->db->where('id', $id);
$affected_rows = $this->db->delete('mytable');
echo $affected_rows;  // 1
```

An array of table names can be passed into delete() if you would like to delete data from more than 1 table.

```php
$tables = array('table1', 'table2', 'table3');
$this->db->where('id', '5');
$this->db->delete($tables);
```

### Method Chaining<a name="method-chaining"></a>

------

Method chaining allows you to simplify your syntax by connecting multiple functions. Consider this example:

```php
$this->db
->select('title')
->from('mytable')
->where('id', $id)
->limit(10, 20)
->get();
```

### Query Binding

```php
$this->db->prep()  // tell to db class use pdo prepare
->select("DATE_FORMAT(creation_date, '%d-%m-%Y') as date, title",false)
->where('title', ':title')
->where('title', ':title2')
->get('articles')           // get Function will be passive when u use prep()
->bindValue(':title', 'my title', PARAM_STR) 
->bindValue(':title2', 'my title', PARAM_STR)
->exec();

$a = $this->db->getResultArray();

print_r($a); // Array ( [0] => Array ( [date] => 00-00-0000 [title] => my title ) ) 

echo $this->db->getLastQuery(true);

// Query output:
```

### Active Record Caching<a name="active-record-chaining"></a>

------

While not <b>true</b> caching, Active Record enables you to save (or <b>cache</b>) certain parts of your queries for reuse at a later point in your script's execution. Normally, when an Active Record call is completed, all stored information is reset for the next call. With caching, you can prevent this reset, and reuse information easily.

Cached calls are cumulative. If you make 2 cached select() calls, and then 2 uncached select() calls, this will result in 4 select() calls. There are three Caching functions available:


#### $this->db->startCache()

This function must be called to begin caching. All Active Record queries of the correct type (see below for supported queries) are stored for later use.

#### $this->db->stopCache()

This function can be called to stop caching.

#### $this->db->flushCache()

This function deletes all items from the Active Record cache.

Here's a usage example:

```php
$this->db->startCache();
$this->db->select('field1');
$this->db->stopCache();

$this->db->get('tablename');

//Generates: SELECT `field1` FROM (`tablename`)

$this->db->select('field2');
$this->db->get('tablename');

//Generates: SELECT `field1`, `field2` FROM (`tablename`)

$this->db->flushCache();

$this->db->select('field2');
$this->db->get('tablename');

//Generates: SELECT `field2` FROM (`tablename`)
```

**Note:** The following statements can be cached: <kbd>select, from, join, where, like, groupby, having, orderby, set</kbd>